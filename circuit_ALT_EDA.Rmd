---
title: "EDA on circuit and average lap time"
output:
  github_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(modelr)
```

```{r get datasets, include = FALSE}
df_results <-  read_csv("data/results.csv")
df_races <- read_csv("data/races.csv")
df_laptimes <- read_csv("data/lap_times.csv")
df_pitstops <-  read_csv("data/pit_stops.csv")
df_drivers <- read_csv("data/drivers.csv")
df_constructors <- read_csv("data/constructors.csv")
df_status <- read_csv("data/status.csv")
df_circuits = read_csv('data/circuits.csv')
```

## Tidying data and joining additional information columns
```{r driver tidying}
# throw out extraneous/irrelevant columns
df_results_trim <- 
  df_results %>%
  select(-c(time, position, positionText, points, grid, number))

# select which attributes to keep about each driver
df_drivers_trim <-
  df_drivers %>%
  unite(driver_name, c(forename, surname), sep = " ") %>% # driver's full name
  select(driverId, driver_name, driver_nationality=nationality)
df_results_plusdrivers <- left_join(df_results_trim, df_drivers_trim, by = "driverId")

# select which attributes to keep about each constructor
df_constructors_trim <-
  df_constructors %>%
  select(constructorId, constructor_name=name, constructor_nationality=nationality)
df_results_plusconstructors <- left_join(df_results_plusdrivers, df_constructors_trim, by = "constructorId")

# select which attributes to keep about each race
df_races_trim <-
  df_races %>%
  select(raceId, year, round, circuitId, race_name=name)
df_results_plusraces <- left_join(df_results_plusconstructors, df_races_trim, by = "raceId")

# get status from statusId
df_results_plusstatus <- left_join(df_results_plusraces, df_status, by = "statusId")

# select which attributes to keep about each circuit
df_circuits_trim <-
  df_circuits %>% 
  select(circuitId, circuit_name=name, circuitRef, circuit_country=country) 
df_results_pluscircuits <- left_join(df_results_plusstatus, df_circuits_trim, by = c("circuitId"))

# turn all \\N into NAs
df_clean <-
  df_results_pluscircuits %>%
  mutate_all(na_if, "\\N")
df_clean
```

## Filtering on drivers that drove for multiple constructors (not currently in use)
``` {r drivers that drove for multiple constructors}
df_multi_drivers <-
  df_clean %>%
  
  # get one datapoint of each pair of driver and constructor
  group_by(driver_name, constructor_name) %>%
  filter(row_number() == 1) %>%
  
  # get how many constructors that each driver has driven for
  group_by(driver_name) %>%
  mutate(driver_numconstr = n()) %>%
  
  # keep drivers that drove for more than one constructor
  filter(driver_numconstr > 1, row_number() == 1) %>%
  select(driver_name) %>% 
  arrange(driver_name)
df_multi_drivers

# get all of the races "multi drivers" drove
df_results_multi_drivers <- inner_join(df_clean, df_multi_drivers, by = "driver_name")
df_results_multi_drivers %>% 
  arrange(driver_name)
```

## Computing Average Lap Time

Using average lap time as our indicator of performance:

 - Accounts for only the laps that the driver was able to complete, excluding when collisions or car troubles have happened, unlike final position.
 - Good overall performance indicator of the race, unlike fastest lap time which is only one lap out of many.
 - The only problem is that it doesn't account for the difficulty of the circuit, so we need a metric for how hard a circuit is - average lap time for that entire circuit

```{r}
df_avglaptime <-
  df_laptimes %>% 
  group_by(driverId, raceId) %>%
  summarize(total_time = sum(milliseconds), avg_lap = total_time / n())

df_with_avglaptime <- left_join(df_clean, df_avglaptime, by = c("driverId", "raceId"))
df_with_avglaptime <-
  df_with_avglaptime %>% 
  filter(!is.na(avg_lap))

df_with_avglaptime <-
  df_with_avglaptime %>% 
  group_by(circuitId) %>%
  mutate(circuit_avg_lap = mean(avg_lap), circuit_lap_sd = sd(avg_lap))
df_with_avglaptime
```

```{r}
df_with_avglaptime %>%
  ggplot(aes(fct_reorder(as.factor(circuitId), circuit_avg_lap), circuit_avg_lap)) + 
  #ggplot(aes(fct_reorder(circuitRef, circuit_avg_lap), circuit_avg_lap)) + 
  geom_point() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  labs(
    x = "Circuit ID number",
    y = "Average lap time (ms)"
  )
```
 
 
## Standardizing Average Lap Time
 
Looking at average lap time per circuit, we see a big difference. We will need to create a metric that allows us to compare average lap time across circuits. 
 
Ratio (avg_lap/circuit_avg_lap) doesn't work because it doesn't account for the variability of average lap time; some circuits can be completed much faster than average while others have a minimum average lap time just below the average. This may be due to factors such as the of the shape of the circuit, for example how many sharp turns it has.
 
How about we standardize average lap time using the following equations:

$$\mu = \sum_{i}^{n} \frac{x_i}{n}$$

$$\sigma = \sqrt{\sum_{i}^{n} \frac{(x_i - \mu)^2}{n}}$$

$$z = \frac{x-\mu}{\sigma}$$

where $x$ is the data, $\mu$ is the mean, $\sigma$ is the standard deviation, and $z$ is the standard score of $x$

 
```{r}
df_with_stdavglap <- 
  df_with_avglaptime %>%
  mutate(std_avg_lap = (avg_lap-circuit_avg_lap)/circuit_lap_sd)
df_with_stdavglap

df_with_stdavglap %>%
  select(raceId, driverId, positionOrder, laps, status, avg_lap, std_avg_lap)
```

Interestingly, although positionOrder and lap time standardized by circuit have some relationship, there are some notable examples that I have found in race 18 where this isn't the case:
 
 - Driver 6 had a status of "+1 Lap" (meaning that they were lapped by the car ahead of them) and a notably larger average lap time than the 5th and 7th place. That caused the std_avg_lap to be much higher than its' neighbors. It appears that this driver only received 6th place because they completed more laps of the race than the 7th place driver was able to.
 - The driver placing 16th had a very high std_avg_lap, possibly due to their Hydraulics issue shown in status, yet place 22 went to someone with a lower std_avg_lap because they were Disqualified.
 - Interestingly, driver 7 had a lower std_avg_lap than driver 8, but completed 2 more laps. Completing more of the race must have earned them a higher place, but driver 8 was actually performing better before they had engine trouble. 
 - The same swapped position order and std_avg_lap can be seen with drivers 9 and 10.
 
These examples illustrate how the metric of std_avg_lap effectively combats the impact of status and number of laps driven while still capturing overall performance in a way that is comparable cross-circuit, something that the metrics positionOrder and fastestLapSpeed cannot do. 

This std_avg_lap metric also highlights how variable the results of formula races can be due to car breakdowns and collisions, that the final ranking isn't necessarily indicative of performance if the racer was unable to finish the whole race. Then again, is car trouble just part of the nature of this sport? Is completing as much of the race as possible actually a requirement because it tests endurance as well as speed, so in excluding the number of laps completed we could be losing some aspect of race performance? Or are car breakdowns and collisions considered to be random and unfortunate events?

```{r}
df_with_stdavglap %>%
  ggplot(aes(as.factor(positionOrder), std_avg_lap)) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  labs(
    x = "Position number",
    y = "standardized average lap time",
    title = "Comparing standardized average lap time by final position"
  )

df_with_stdavglap %>%
  ggplot(aes(as.factor(positionOrder), std_avg_lap)) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  ylim(-2, 2) +
  labs(
    x = "Position number",
    y = "standardized average lap time",
    title = "Comparing standardized average lap time by final position"
  )

df_with_stdavglap %>%
  filter(circuitId %% 2 == 1) %>%
  ggplot(aes(as.factor(positionOrder), std_avg_lap)) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  facet_wrap(vars(circuitId)) +
  labs(
    x = "Position number",
    y = "standardized average lap time",
    title = "Comparing standardized average lap time by final position"
  )
```

First of all, the graph of standardized average lap time by final position shown above confirms the obvious: final ranking and standardized average lap time are related. The faster you drive, the more likely you are to win the race! 

Secondly, the graph faceted by circuit shows that this relationship is different for each track, and that there is an increasing variability in the higher positions. This is almost certainly explained by the fact that collisions or other car troubles reduce the likelihood of being able to finish the race, thus increasing their position number, independent of how well they were performing before their accident. 

Also, I hypothesize that the vertical stratification is due to more competitive races raising the standard for placing high, even when competing on the same track.

## Downselecting final data
```{r}
df_final <-
  df_with_stdavglap %>%
  # Getting rid of less useful cols
  select(-c(resultId, milliseconds, rank, fastestLap, fastestLapTime, fastestLapSpeed, circuit_avg_lap, circuit_lap_sd, circuitRef)) %>%
  
  # Getting rid of country info
  select(-c(driver_nationality, constructor_nationality, circuit_country)) %>%

  # Getting rid of cols represented two different ways 
  select(-c(race_name, driverId, constructorId, circuit_name, statusId)) %>%
  
  # Getting rid of less useful metrics
  select(-c(laps, total_time, avg_lap))

df_final

df_final %>%
  ggplot(aes(fct_reorder(as.factor(circuitId), std_avg_lap), std_avg_lap)) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  labs(
    x = "Circuit ID number",
    y = "standardized average lap time",
    title = "Comparing standardized average lap time by circuit"
  )

df_final %>%
  ggplot(aes(fct_reorder(as.factor(circuitId), std_avg_lap), std_avg_lap)) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)) + 
  labs(
    x = "Circuit ID number",
    y = "standardized average lap time",
    title = "Comparing standardized average lap time by circuit"
  ) + 
  ylim(-2, 2)

```

I am using this graph to visually compare the mean, quantiles, and outliers of standardized average lap time by circuit in order to check that std_avg_lap minimizes the effect of circuit as much as possible. Generally, it seems that it does, because the mean stays at an absolute value less than 0.5 for almost every circuit. 

However, circuits 16 and 76 seem like high outliers and circuits 73, 10, and 35 seem like low outliers. Interestingly, there are no high outlying datapoints for the 4 circuits with the highest std_avg_lap. Perhaps the outliers in the mean std_alt are caused by track length? I know that 73 is the Red Bull track, which is one of the shortest in all of Formula racing. I want to investigate why these are outliers and if there is a way to account for them better using a different or modified metric.